#!/usr/bin/env python
#
# This is a Git post-receive hook script that assumes that the current repository
# is getting sent changesets for review. This script does the job of taking those
# changesets and sending them to ta Review Board instance for review.

import os
import re
import subprocess
import sys

from ConfigParser import ConfigParser

from rbtools.api.client import RBClient
from rbtools.utils.process import execute

from gitcommititerator import GitCommitIterator


CONFIG_FILE = os.path.join('hooks', 'config.cfg')


def generate_diff(base_ref, tip_ref):
    """Performs a diff on a particular ref range."""
    if base_ref == tip_ref:
        rev_range = "%s..%s^" % (base_ref, tip_ref)
    else:
        rev_range = "%s..%s" % (base_ref, tip_ref)

    cmdline = [
        "git",
        "diff",
        "--no-color",
        "--full-index",
        "--no-ext-diff",
        "--ignore-submodules",
        "--no-renames",
        "-M",
        rev_range
    ]

    return execute(cmdline)


def get_original_branch():
    """Finds the original branch this review request change was based on."""
    pass


def get_api(server_url, username, password):
    """Returns an RBClient instance and the associated root resource."""
    api_client = RBClient(server_url, username=username, password=password)
    api_root = api_client.get_root()

    return api_client, api_root


def get_named_branches():
    """Returns a list of hashes for named branches."""
    cmdline = [
        'git',
        'show-ref',
    ]
    lines = [x.strip() for x in execute(cmdline, split_lines=True)]
    result = {}
    for line in lines:
        splitted = line.split(' ')
        result[splitted[0]] = splitted[1]
    return result


def get_named_branch_for_rev(rev, namedBranches):
    """Given some commit rev, goes up the ancestry chain until
       it finds a named branch.
    """
    iterator = GitCommitIterator(rev)
    for rev in iterator:
      if rev in namedBranches:
        return rev, namedBranches[rev]
    return None


def get_parent_for_rev(rev):
    """Return the rev for the parent of a commit."""
    iterator = GitCommitIterator(rev)
    return rev.next()


def get_request_for_commit(root, ref):
    """Retrieve the review request associated with a specific commit."""
    requests = root.get_review_requests(commit_id=ref)
    return (requests.total_results and requests[0]) or None


def extract_summary(base, tip):
    """Extracts the summary based on the provided revisions."""
    return execute(
        [
            'git',
            'log',
            '--reverse',
            '--pretty=format:%s',
            '^%s' % base,
            tip
        ],
        ignore_errors=True,
        split_lines=True)[0].strip()


def extract_description(base, tip):
    """Extracts the description based on the provided revision range."""
    return execute(
        [
            'git',
            'log',
            '--reverse',
            '--pretty=format:%s%n%n%b',
            '^%s' % base,
            tip
        ],
        ignore_errors=True).strip()


def post_reviews(root, repository_id, data):
    requests = root.get_review_requests()
    previous_change = None
    review_requests = []

    for change in data['changesets']:

        base_commit = ((previous_change and previous_change['newrev']) or
                       data['squashed']['parent'])

        diff_content = generate_diff(change['newrev'], change['newrev'])
        summary = extract_summary(change['newrev'], change['newrev'])
        description = extract_description(change['newrev'], change['newrev'])

        review_request_data = {
            'summary': extract_summary(change['newrev'], change['newrev']),
            'description': extract_description()
        }

        if change['oldrev'] and change['newrev']:
            # We are updating the old commits review request
            # with a new commit.
            request = get_request_for_commit(root, change['oldrev'])
        else:
            # TODO: Don't just assume we will have a newrev in this case.
            # in the future when we deal with commit reordering a deletion
            # we'll want to discard review requests where the newrev is
            # blank.

            # TODO: We need to detect the user account of the push
            # here and set `submit_as=<user>`.
            request = requests.create(repository=repository_id)

        diffs = request.get_diffs()
        diff = diffs.create(diff_content, base_commit_id=base_commit)

        draft = request.get_draft()
        draft.update(
            summary=summary,
            description=description,
            branch=data['base_branch'],
            bugs_closed="TODO-BUG-HERE",
            depends_on=(previous_change and previous_change['request']) or "",
            public=True)


        # We always keep track of the last change where we had a commit
        # in the current push, so that we can set the following requests
        # depends on field.
        if change['newrev']:
            previous_change = change
            previous_change['request'] = request.id

            review_request.append({
                'summary': summary,
                'id': request.id,
            })

    # Finally, we will compile the data for the "squashed" review request
    # and post it.
    summary = "Squashed Commits for %s" % data['push_branch']
    description = []
    for request in review_requests:
        description.append("r/%s - %s" % (request['id'], request['summary']))

    description = '\n'.join(description)
    diff_content = generate_diff(data['squashed']['base'],
                                 data['squashed']['head'])

    request = get_request_for_commit(root, data['push_branch'])

    if request is None:
        request = requests.create(repository=repository_id)

    diffs = request.get_diffs()
    diff = diffs.create(diff_content,
                        base_commit_id=data['squashed']['parent'])

    draft = request.get_draft()
    draft.update(
        summary=summary,
        description=description,
        branch=data['base_branch'],
        bugs_closed="TODO-BUG-HERE",
        depends_on=(previous_change and previous_change['request']) or "",
        public=True)


def main():
    # We'll start by reading in the configuration for this hook...
    config = ConfigParser()
    config.readfp(open(CONFIG_FILE))
    reviewboard_url = config.get('RB', 'url')
    username = config.get('RB', 'username')
    password = config.get('RB', 'password')
    named_branches = get_named_branches()
    repository_id = config.get('RB', 'repository_id')

    result = {}
    # The "post-receive" script is run after receive-pack has accepted a pack
    # and the repository has been updated.  It is passed arguments in through
    # stdin in the form
    #  <oldrev> <newrev> <refname>
    # For example:
    #  aa453216d1b3e49e7f6f98441fa56946ddcd6a20 68f7abf4e6f922807889f52bc043ecd31b79f814 refs/heads/master
    #
    # We need all three, so let's extract those. We might be getting several of
    # these changesets as well, so we have to iterate the stdin lines.
    changesets = []
    push_branch = None
    base_rev = None
    new_revs = []

    for line in sys.stdin:
        args = line.strip().split(' ')
        changeset = {}
        changeset['oldrev'] = args[0]
        changeset['newrev'] = args[1]
        new_revs.append(changeset['newrev'])
        if not push_branch:
            result['push_branch'] = args[2]
        changesets.append(changeset)

    result['changesets'] = changesets

    # Finally, we need to provide the "squashed" part of the result,
    # which we'll use to fold all of the changesets together into a
    # single over-arching review request.
    result['squashed'] = {}
    result['squashed']['head'] = new_revs[0]
    result['squashed']['base'] = new_revs[-1]

    # Grab a changeset, and walk up their ancestry chain until we
    # hit a named remote branch. We'll use that for our "base_branch".
    changeset = changesets[0]
    parent_rev, parent_branch = get_named_branch_for_rev(changeset['newrev'], named_branches)
    result['squashed']['parent'] = parent_rev

    # Create the RB api client and retrieve the root resource.
    api, root = get_api(reviewboard_url, username, password)
    post_reviews(root, repository_id, result)

if __name__ == '__main__':
    main()
